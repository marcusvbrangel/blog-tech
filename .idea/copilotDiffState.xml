<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/test/java/com/blog/api/service/CategoryServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/blog/api/service/CategoryServiceTest.java" />
              <option name="originalContent" value="package com.blog.api.service;&#10;&#10;import com.blog.api.dto.CategoryDTO;&#10;import com.blog.api.entity.Category;&#10;import com.blog.api.exception.BadRequestException;&#10;import com.blog.api.exception.ResourceNotFoundException;&#10;import com.blog.api.repository.CategoryRepository;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageImpl;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.assertj.core.api.Assertions.assertThatThrownBy;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Category Service Tests&quot;)&#10;class CategoryServiceTest {&#10;&#10;    private final CategoryRepository categoryRepository;&#10;&#10;    @InjectMocks&#10;    private CategoryService categoryService;&#10;&#10;    private Category testCategory;&#10;    private CategoryDTO categoryDTO;&#10;    private Pageable pageable;&#10;&#10;    CategoryServiceTest(CategoryRepository categoryRepository) {&#10;        this.categoryRepository = categoryRepository;&#10;    }&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        testCategory = Category.of(&quot;Technology&quot;, &quot;Tech related posts&quot;)&#10;                .build();&#10;        testCategory.setId(1L);&#10;&#10;        categoryDTO = new CategoryDTO(1L, &quot;Technology&quot;, &quot;Tech related posts&quot;, 0);&#10;        pageable = PageRequest.of(0, 10);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma página de CategoryDTOs quando buscar todas as categorias&quot;)&#10;    void getAllCategories_ShouldReturnPageOfCategoryDTOs() {&#10;        // Arrange&#10;        Page&lt;Category&gt; categoryPage = new PageImpl&lt;&gt;(Arrays.asList(testCategory), pageable, 1);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(categoryPage);&#10;        when(categoryRepository.count()).thenReturn(1L);&#10;&#10;        // Act&#10;        Page&lt;CategoryDTO&gt; result = categoryService.getAllCategories(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.getContent()).hasSize(1);&#10;        assertThat(result.getContent().get(0).name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.getContent().get(0).description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        assertThat(result.getTotalElements()).isEqualTo(1L);&#10;        verify(categoryRepository).findAll(pageable);&#10;        verify(categoryRepository).count();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma página vazia quando não existirem categorias&quot;)&#10;    void getAllCategories_ShouldReturnEmptyPageWhenNoCategories() {&#10;        // Arrange&#10;        Page&lt;Category&gt; emptyPage = new PageImpl&lt;&gt;(Arrays.asList(), pageable, 0);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(emptyPage);&#10;        when(categoryRepository.count()).thenReturn(0L);&#10;&#10;        // Act&#10;        Page&lt;CategoryDTO&gt; result = categoryService.getAllCategories(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.getContent()).isEmpty();&#10;        assertThat(result.getTotalElements()).isEqualTo(0L);&#10;        verify(categoryRepository).findAll(pageable);&#10;        verify(categoryRepository).count();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma lista de CategoryDTOs quando buscar todas as categorias como lista&quot;)&#10;    void getAllCategoriesList_ShouldReturnListOfCategoryDTOs() {&#10;        // Arrange&#10;        Page&lt;Category&gt; categoryPage = new PageImpl&lt;&gt;(Arrays.asList(testCategory), pageable, 1);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(categoryPage);&#10;&#10;        // Act&#10;        List&lt;CategoryDTO&gt; result = categoryService.getAllCategoriesList(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result).hasSize(1);&#10;        assertThat(result.get(0).name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.get(0).description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        verify(categoryRepository).findAll(pageable);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar CategoryDTO quando buscar categoria por ID existente&quot;)&#10;    void getCategoryById_ShouldReturnCategoryDTO_WhenCategoryExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.getCategoryById(categoryId);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.id()).isEqualTo(categoryId);&#10;        assertThat(result.name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        verify(categoryRepository).findById(categoryId);&#10;    }&#10;&#10;    @Test&#10;    void getCategoryById_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.getCategoryById(categoryId))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;    }&#10;&#10;    @Test&#10;    void createCategory_ShouldCreateAndReturnCategoryDTO_WhenValidData() {&#10;        // Arrange&#10;        CategoryDTO newCategoryDTO = new CategoryDTO(null, &quot;Science&quot;, &quot;Science related posts&quot;, 0);&#10;        when(categoryRepository.existsByName(&quot;Science&quot;)).thenReturn(false);&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.createCategory(newCategoryDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.name()).isEqualTo(&quot;Technology&quot;);&#10;        verify(categoryRepository).existsByName(&quot;Science&quot;);&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    void createCategory_ShouldThrowBadRequestException_WhenCategoryNameAlreadyExists() {&#10;        // Arrange&#10;        CategoryDTO newCategoryDTO = new CategoryDTO(null, &quot;Technology&quot;, &quot;Tech related posts&quot;, 0);&#10;        when(categoryRepository.existsByName(&quot;Technology&quot;)).thenReturn(true);&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.createCategory(newCategoryDTO))&#10;                .isInstanceOf(BadRequestException.class)&#10;                .hasMessageContaining(&quot;Category name already exists&quot;);&#10;        &#10;        verify(categoryRepository).existsByName(&quot;Technology&quot;);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    void updateCategory_ShouldUpdateAndReturnCategoryDTO_WhenValidData() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Updated Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.existsByName(&quot;Updated Technology&quot;)).thenReturn(false);&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.updateCategory(categoryId, updateDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).existsByName(&quot;Updated Technology&quot;);&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    void updateCategory_ShouldUpdateWithSameName_WhenNameNotChanged() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.updateCategory(categoryId, updateDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).existsByName(any());&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    void updateCategory_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Updated Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.updateCategory(categoryId, updateDTO))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    void updateCategory_ShouldThrowBadRequestException_WhenNewNameAlreadyExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Existing Category&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.existsByName(&quot;Existing Category&quot;)).thenReturn(true);&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.updateCategory(categoryId, updateDTO))&#10;                .isInstanceOf(BadRequestException.class)&#10;                .hasMessageContaining(&quot;Category name already exists&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).existsByName(&quot;Existing Category&quot;);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    void deleteCategory_ShouldDeleteCategory_WhenCategoryExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;&#10;        // Act&#10;        categoryService.deleteCategory(categoryId);&#10;&#10;        // Assert&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).delete(testCategory);&#10;    }&#10;&#10;    @Test&#10;    void deleteCategory_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.deleteCategory(categoryId))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).delete(any(Category.class));&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.blog.api.service;&#10;&#10;import com.blog.api.dto.CategoryDTO;&#10;import com.blog.api.entity.Category;&#10;import com.blog.api.exception.BadRequestException;&#10;import com.blog.api.exception.ResourceNotFoundException;&#10;import com.blog.api.repository.CategoryRepository;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageImpl;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.assertj.core.api.Assertions.assertThatThrownBy;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Category Service Tests&quot;)&#10;class CategoryServiceTest {&#10;&#10;    private final CategoryRepository categoryRepository;&#10;&#10;    @InjectMocks&#10;    private CategoryService categoryService;&#10;&#10;    private Category testCategory;&#10;    private CategoryDTO categoryDTO;&#10;    private Pageable pageable;&#10;&#10;    CategoryServiceTest(CategoryRepository categoryRepository) {&#10;        this.categoryRepository = categoryRepository;&#10;    }&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        testCategory = Category.of(&quot;Technology&quot;, &quot;Tech related posts&quot;)&#10;                .build();&#10;        testCategory.setId(1L);&#10;&#10;        categoryDTO = new CategoryDTO(1L, &quot;Technology&quot;, &quot;Tech related posts&quot;, 0);&#10;        pageable = PageRequest.of(0, 10);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma página de CategoryDTOs quando buscar todas as categorias&quot;)&#10;    void getAllCategories_ShouldReturnPageOfCategoryDTOs() {&#10;        // Arrange&#10;        Page&lt;Category&gt; categoryPage = new PageImpl&lt;&gt;(Arrays.asList(testCategory), pageable, 1);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(categoryPage);&#10;        when(categoryRepository.count()).thenReturn(1L);&#10;&#10;        // Act&#10;        Page&lt;CategoryDTO&gt; result = categoryService.getAllCategories(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.getContent()).hasSize(1);&#10;        assertThat(result.getContent().get(0).name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.getContent().get(0).description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        assertThat(result.getTotalElements()).isEqualTo(1L);&#10;        verify(categoryRepository).findAll(pageable);&#10;        verify(categoryRepository).count();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma página vazia quando não existirem categorias&quot;)&#10;    void getAllCategories_ShouldReturnEmptyPageWhenNoCategories() {&#10;        // Arrange&#10;        Page&lt;Category&gt; emptyPage = new PageImpl&lt;&gt;(Arrays.asList(), pageable, 0);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(emptyPage);&#10;        when(categoryRepository.count()).thenReturn(0L);&#10;&#10;        // Act&#10;        Page&lt;CategoryDTO&gt; result = categoryService.getAllCategories(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.getContent()).isEmpty();&#10;        assertThat(result.getTotalElements()).isEqualTo(0L);&#10;        verify(categoryRepository).findAll(pageable);&#10;        verify(categoryRepository).count();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar uma lista de CategoryDTOs quando buscar todas as categorias como lista&quot;)&#10;    void getAllCategoriesList_ShouldReturnListOfCategoryDTOs() {&#10;        // Arrange&#10;        Page&lt;Category&gt; categoryPage = new PageImpl&lt;&gt;(Arrays.asList(testCategory), pageable, 1);&#10;        when(categoryRepository.findAll(pageable)).thenReturn(categoryPage);&#10;&#10;        // Act&#10;        List&lt;CategoryDTO&gt; result = categoryService.getAllCategoriesList(pageable);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result).hasSize(1);&#10;        assertThat(result.get(0).name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.get(0).description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        verify(categoryRepository).findAll(pageable);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve retornar CategoryDTO quando buscar categoria por ID existente&quot;)&#10;    void getCategoryById_ShouldReturnCategoryDTO_WhenCategoryExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.getCategoryById(categoryId);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.id()).isEqualTo(categoryId);&#10;        assertThat(result.name()).isEqualTo(&quot;Technology&quot;);&#10;        assertThat(result.description()).isEqualTo(&quot;Tech related posts&quot;);&#10;        verify(categoryRepository).findById(categoryId);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar ResourceNotFoundException quando buscar categoria por ID inexistente&quot;)&#10;    void getCategoryById_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.getCategoryById(categoryId))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve criar e retornar CategoryDTO quando os dados são válidos&quot;)&#10;    void createCategory_ShouldCreateAndReturnCategoryDTO_WhenValidData() {&#10;        // Arrange&#10;        CategoryDTO newCategoryDTO = new CategoryDTO(null, &quot;Science&quot;, &quot;Science related posts&quot;, 0);&#10;        when(categoryRepository.existsByName(&quot;Science&quot;)).thenReturn(false);&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.createCategory(newCategoryDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        assertThat(result.name()).isEqualTo(&quot;Technology&quot;);&#10;        verify(categoryRepository).existsByName(&quot;Science&quot;);&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar BadRequestException quando o nome da categoria já existe&quot;)&#10;    void createCategory_ShouldThrowBadRequestException_WhenCategoryNameAlreadyExists() {&#10;        // Arrange&#10;        CategoryDTO newCategoryDTO = new CategoryDTO(null, &quot;Technology&quot;, &quot;Tech related posts&quot;, 0);&#10;        when(categoryRepository.existsByName(&quot;Technology&quot;)).thenReturn(true);&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.createCategory(newCategoryDTO))&#10;                .isInstanceOf(BadRequestException.class)&#10;                .hasMessageContaining(&quot;Category name already exists&quot;);&#10;        &#10;        verify(categoryRepository).existsByName(&quot;Technology&quot;);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve atualizar e retornar CategoryDTO quando os dados são válidos&quot;)&#10;    void updateCategory_ShouldUpdateAndReturnCategoryDTO_WhenValidData() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Updated Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.existsByName(&quot;Updated Technology&quot;)).thenReturn(false);&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.updateCategory(categoryId, updateDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).existsByName(&quot;Updated Technology&quot;);&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve atualizar categoria mantendo o mesmo nome quando o nome não é alterado&quot;)&#10;    void updateCategory_ShouldUpdateWithSameName_WhenNameNotChanged() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);&#10;&#10;        // Act&#10;        CategoryDTO result = categoryService.updateCategory(categoryId, updateDTO);&#10;&#10;        // Assert&#10;        assertThat(result).isNotNull();&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).existsByName(any());&#10;        verify(categoryRepository).save(any(Category.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar ResourceNotFoundException quando tentar atualizar categoria inexistente&quot;)&#10;    void updateCategory_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Updated Technology&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.updateCategory(categoryId, updateDTO))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar BadRequestException quando o novo nome já existe em outra categoria&quot;)&#10;    void updateCategory_ShouldThrowBadRequestException_WhenNewNameAlreadyExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        CategoryDTO updateDTO = new CategoryDTO(null, &quot;Existing Category&quot;, &quot;Updated description&quot;, 0);&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;        when(categoryRepository.existsByName(&quot;Existing Category&quot;)).thenReturn(true);&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.updateCategory(categoryId, updateDTO))&#10;                .isInstanceOf(BadRequestException.class)&#10;                .hasMessageContaining(&quot;Category name already exists&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).existsByName(&quot;Existing Category&quot;);&#10;        verify(categoryRepository, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve deletar categoria quando ela existe&quot;)&#10;    void deleteCategory_ShouldDeleteCategory_WhenCategoryExists() {&#10;        // Arrange&#10;        Long categoryId = 1L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.of(testCategory));&#10;&#10;        // Act&#10;        categoryService.deleteCategory(categoryId);&#10;&#10;        // Assert&#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository).delete(testCategory);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Deve lançar ResourceNotFoundException quando categoria a ser deletada não existe&quot;)&#10;    void deleteCategory_ShouldThrowResourceNotFoundException_WhenCategoryNotExists() {&#10;        // Arrange&#10;        Long categoryId = 999L;&#10;        when(categoryRepository.findById(categoryId)).thenReturn(Optional.empty());&#10;&#10;        // Act &amp; Assert&#10;        assertThatThrownBy(() -&gt; categoryService.deleteCategory(categoryId))&#10;                .isInstanceOf(ResourceNotFoundException.class)&#10;                .hasMessageContaining(&quot;Category&quot;)&#10;                .hasMessageContaining(&quot;id&quot;)&#10;                .hasMessageContaining(&quot;999&quot;);&#10;        &#10;        verify(categoryRepository).findById(categoryId);&#10;        verify(categoryRepository, never()).delete(any(Category.class));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>